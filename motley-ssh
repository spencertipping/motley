#!/bin/bash
# Motley SSH command definition
motley_defmodule ssh <<'EOF'
SSH command
Defines an SSH service endpoint, optionally creating a named entry in
~/.ssh/config.

  foo ssh -l myself             # always use user "myself" to connect to foo
  foo ssh f -l myself           # create a connection f with user "myself"
  foo ssh f                     # create a connection f for host foo

If you name an SSH connection, you can refer to it as if it were a machine:

  f docker ...                  # configure docker using ssh connection f

Naming SSH connections is done by creating entries in ~/.ssh/config. Any such
names will have corresponding bash aliases.
EOF

motley_defcommand ssh

motley_ssh_init() { motley_confedit motley_ssh_config ~/.ssh/config; }
motley_ssh_end()  { motley_confedit_commit motley_ssh_config; }

motley_ssh_options_to_config() {
  while (( $# )); do
    case $1 in
      -l) echo "User $2";               shift 2 ;;
      -p) echo "Port $2";               shift 2 ;;
      -i) echo "IdentityFile $2";       shift 2 ;;
      -o) echo "$2";                    shift 2 ;;
      -C) echo "Compression yes";       shift 1 ;;
      -X) echo "ForwardX11 yes";        shift 1 ;;
      -Y) echo "ForwardX11Trusted yes"; shift 1 ;;
      *)
        echo "motley: unsure how to convert $1 to ~/.ssh/config syntax" >&2
        echo "        (ignoring this for now, but it's probably a bug)" >&2
        echo "        a workaround is to use '-o ...' instead"          >&2
        shift
        ;;
    esac
  done
}

motley_ssh() {
  # Are we defining a named alias? If so, then create a new "machine" that will
  # use it. This works because as far as motley is concerned, commands are
  # going to an entirely different place.
  local machine_key=$1
  local machine=$2
  local mode=$3
  shift 3

  if [[ ${1#-} = $1 ]]; then
    machine $1
    echo "TODO: update ssh config (1)"
  else
    # Set machine-level defaults for SSH connection
    echo "TODO: update ssh config (2)"
  fi
}
